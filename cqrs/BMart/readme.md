해당 포스팅은 "B마트 전시 도메인 CQRS 적용하기"라는 강연의 내용을 정리한 글이다.
- https://www.youtube.com/watch?v=fg5xbs59Lro

## CQRS

CQRS는 Command and Query Responsibility Segregation의 약자로 **명령과 조회의 책임을 분리**라는 뜻이다.

이전에 CQRS의 내용을 정리한 적이 있는데 외부 강연들을 보면서 추가로 궁금한 사항들이 생겼다.
- 왜 조회 모델은 DB에 저장을 할까..?!, ...

이전 포스팅은 아래 링크를 참고하자.
- https://jaehoney.tistory.com/255

**B마트 전시 도메인 CQRS 적용하기**라는 강연에서 CQRS에 대해 더 자세히 설명해준다. 해당 강연을 보고 추가적으로 알게된 사실을 해당 포스팅에서 작성하려고 한다.

## 내부 데이터와 외부 데이터

우리는 DB에서 도메인 모델을 꺼낼 수도 있지만, MSA를 적용하고 있다면 외부 API를 통해 모델을 조회할 수도 있다.

![img.png](img.png)

단일 도메인 모델을 사용하면 **명령 관련 로직**과 **조회 관련 로직**이 함께 존재할 수 밖에 없다.

이때 외부 API를 통해 불러온 모델은 Hibernate에서 관리할 수 있는 모델이 아니기에 모델을 다루기에 훨씬 복잡해지고, 변경 용이성이 떨어지게 된다.

![img_1.png](img_1.png)

그래서 큰 도메인 안에서 명령과 도메인과 조회 도메인을 나눠서 문제를 해결하는 것이 CQRS가 나아가는 방향이다.

- 명령 모델: 기존의 모델
- 조회 모델: 각 모델을 결합한 비정규화된 데이터를 한번 더 정의한 것

## 캐시

조회 모델을 만들기 위해서는 여러 쿼리와 외부 API로의 요청이 필요하다. 이는 당연히 성능상의 부담이 된다.

그래서 Cache를 사용해야 한다. 이때 아래의 문제가 생길 수 있다.
- Heap 메모리 사이즈 부족
- 캐시와의 트래픽량 증가

그래서 명령 모델을 통해 데이터가 변경되는 시점에 조회 모델을 생성하고 비정규화된 데이터를 그대로 DB에 다시 저장한다.
- CQRS의 조회모델을 DB로부터 가져오는 과정에서 조인이나 여타 연산을 제한해야 한다.
- 그래서 비정규화된 데이터를 저장해서 DB에서 데이터를 꺼내서 곧바로 사용할 수 있게 한다.

해당 데이터는 곧바로 사용할 수 있는 비정규화된 데이터이기 때문에 JsonFormat이 주로 이용이된다. 그래서 RDB가 아니라 NoSQL을 사용하는 경우가 많다.
- Redis, Elasticsearch, DynamoDB

단, 이렇게 저장소를 나누면 다른 저장소간 데이터의 정합성을 보장할 수 있어야 하기에, 시스템이 안착할 때 까지는 모니터링에 더 관심을 기울여야 한다.

## 동기화

그렇다면 명령 모델과 조회 모델의 데이터가 불일치가 발생하는 것을 어떻게 막을 수 있을까..?!

B마트에서는 이벤트 소싱 방식으로 명령 모델에서 데이터를 변경하면 이벤트를 날리고, 해당 이벤트를 구독하던 애플리케이션에서 조회모델을 생성하게 된다.

![img_2.png](img_2.png)

## CQRS 모델

CQRS를 적용한다는 것이 **모든 도메인 모델을 대상으로 명령 모델과 조회 모델로 분리하는 것**은 아니다.

고객에게 전시하는 **전시 도메인** 영역에만 적용할 수 있다.

![img_3.png](img_3.png)

B마트에서 가장 복잡한 조회 모델은 카탈로그 모델이라고 한다. 위의 요구사항들을 만족하기 위해 카탈로그 조회 모델은 아래의 전체 트리 모델 하나만 사용하면 된다고 판단했다.

![img_4.png](img_4.png)

하지만 해당 모델을 계속 사용하기엔 큰 무리가 있었다.
- 새로운 UX 요소가 계속 추가되고 있는 상황
- 서비스 전반에 영향을 주는 비즈니스 정책이 많이 추가됨
- 개인화(찜, 장바구니 담았는지 여부, 개인화 추천 구좌)

그래서 전체 트리 모델이 너무 비대해지고 의존성 경계를 넘나드는 경우가 많이 생겼다.

![img_5.png](img_5.png)

추가로 지점 수와 카탈로그 수와 상품 수에 따라 모델의 크기가 곱으로 커지는 구조였고, 사용자 수가 늘면 레디스의 크기를 넘나드는 트래픽을 감당할 수 없는 상황이 되었다.

![img_6.png](img_6.png)

그래서 전체 트리 모델 하나만 사용했을 때 트래픽을 감당할 수 없어서 사방 팔방에 로컬 캐시와 레디스를 적용하게 되었다. 
- 하지만 그만큼 서버의 힙 메모리 사용량이 증가하고 더 이상 데이터 정합성을 맞춰주기가 어려웠다.
- 추가로 전체 트리 모델을 사용하는 곳이 너무 많아져서 근본적인 해결책이 되지 못했다.

그래서 CQRS를 다시 설계해야 했다.

![img_7.png](img_7.png)

위에서 설계한 전체 트리 모델을 제거하고 최소한의 쿼리로 새로운 조회 모델을 만들 수 있도록 정의해야 했다.

그래서 B마트는 **전체 트리 모델에 의존성을 가지고 있던 모든 로직**을 **한 클래스**로 모았다.
- 모으면서 비즈니스 로직이 더 꼬이는 현상도 발생했지만 우직하게(?) 모두 한 클래스로 모았다.

![img_8.png](img_8.png)

그 결과 전체 트리 모델에 의존성을 갖는 **도메인 로직**이 해당 클래스에 남게 되었다. 해당 로직은 카탈로그 목록, 카탈로그, 상품 세 가지 데이터를 통해 만들어 졌다.

![img_9.png](img_9.png)

도메인 로직은 위의 기능들로 정리할 수 있었다. 결과적으로 전체 트리 모델 -> 카탈로그 목록 모델, 카탈로그 모델, 상품 모델로 분리하였고, 이를 조회 모델로서 활용하게 되었다.

![img_10.png](img_10.png)

기존 전체 트리 모델이라는 하나의 조회 모델에 의존하고 각 로직별로 캐시에 의존했던 구조가 적절한 조회 모델로 분배함으로써 도메인 로직이 깔끔하게 나눠지게 되었다. 추가로 해당 조회 모델에만 캐시를 적용하기 때문에 캐시 트래픽도 줄어들 수 있었다.

## 이벤트

해당 조회 모델이 수정되었을 때 이벤트를 통해 조회 모델에도 동기화를 해야 한다. 그래서 이벤트에는 아래의 내용을 담아서 발행이 필요했다.
- 이벤트 변경에 따라 갱신 해야할 대상(카탈로그 or 상품) id
- 변경을 감지할 property 지정
- 실행 Method 지정
- 데이터 변경자 이름

## 참고
- https://www.youtube.com/watch?v=fg5xbs59Lro

