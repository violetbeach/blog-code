## GraphQL 이해하기!

GraphQL 이란 2012년 페이스북의 클라이언트 데이터 전송 방식 개선 목적으로 시작되었다.

GraphQL이란 클라이언트와 서버의 통신 **명세**이다. (REST와 마찬가지로 실체는 없다.)
- 명세를 기반으로 다양한 라이브러리가 생성되었다.

구조(스키마)와 행동(리졸버)로 구성된다.

## vs REST API

GraphQL과 REST API의 차이를 알아보자.

|     | GraphQL                       | REST           |
|-----|-------------------------------|----------------|
| 구성  | 스키마 / 타입 시스템                  | URL endpoints  |
| 동작  | Query, Mutation, Subscription | CRUD           |
| End-point | 단일 접점(API 1개)                 | URL 집합         |
|데이터 포맷| Only JSON                     | JSON, XML, ... |
|관점| 클라이언트 주도 설계                   | 서버 주도 설계       |
|러닝 커브| 어려움                           | 보통 (비교적 쉬움)    |

그러면 이러한 차이는 어떤 장점이 있을까?
- 클라이언트에게 많은 제어권을 넘길 수 있다. (필요한 필드 목록 등을 클라이언트에서 주도할 수 있다.)
- 동일한 스펙(Query)으로 여러 서버에 질의할 수 있다.
- 오버페칭, 언더페칭이 적다.
- 상대적으로 빠르다.

이제 위 특징들을 하나씩 살펴보자.

#### 클라이언트 주도 설계

클라이언트 측은 사용자의 이름을 다음과 같이 질의할 수 있다.

- request: `{ hero { name }}`, response: `{ "hero": { "name": "Luke Skywalker" }}`

이때 이름 뿐만 아니라 키와 머리색도 질의하고 싶다면 다음과 같이 질의할 수 있다.

- request: `{ hero { name height hairColors }}`, response: `{ "hero": { "name": "Luke Skywalker", "height": 1.72, "hairColors": ["black", "brown"] }}`

즉, 클라이언트에서 필요한 필드를 주도적으로 조회할 수 있게 된다.

#### 단일 접점

GraphQL은 API end-point가 하나라서 클라이언트 입장에서 사용하기 편리하다.

#### 오버페칭, 언더페칭

만약 사용자 한명의 많은 필드 중에서 주소만 조회하고 싶은 경우가 있다.

REST의 경우 `GET /사용자/id/주소`가 존재하지 않는다면 GET `/사용자`로 조회를 해야할 것이다. 이때 오버페칭이 발생한다.

반대로 클라이언트의 처리에 필요한 데이터가 부족한 경우도 종종생겨서, 추가 작업을 해야하는 경우가 생긴다. 즉, 언더페칭이 발생한다.

GraphQL을 사용하면 이를 해결할 수 있다.

단, 이러한 요구사항에 맞게 스키마 설계가 되어야 하고 리졸버를 잘 구현하는 것이 필요하다.

## GraphQL 단점

GraphQL도 당연히 장점만 존재하지는 않는다.
- GraphQL 스키마의 유지보수가 필요하다.
  - 스키마 설계
  - 트리 그래프의 깊이 제어
  - ...
- 캐싱 전략을 적용하기 어렵다. (쿼리에 따라 응답이 매우 동적이기 때문)
- 학습 곡선이 크다.

## 문서화

REST API의 경우 Swagger 도구 등을 활용해서 API 스펙을 문서화해야 한다.

GraphQL은 스키마 자체가 API 문서이기 때문 문서화를 할 필요가 없다.

