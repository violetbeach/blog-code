랜덤한 숫자 1억 개의 총 합계를 빠른 시간 내에 구해야 한다.

어떻게 할 수 있을까?

## 선형 누적

일반적으로 아래의 풀이를 떠올릴 수 있다.

```
합계 = 0

반복 1억 번:
    랜덤한_숫자 = 난수_생성() 
    합계 = 합계 + 랜덤한_숫자

결과 출력(합계)
```

이거보다 더 빨리할 수 없을까..?

## 병렬 프로그래밍

위를 위한 특별한 알고리즘은 없다.

정답은 **병렬 프로그래밍**이다.

```
합계 = 0
반복 횟수 = 1_000_000_000
쓰레드_개수 = 시스템_쓰레드_개수()

# 숫자를 쓰레드로 분할하여 합을 계산
각 쓰레드에 할당:
    시작_인덱스 = 현재_쓰레드 * (반복_횟수 // 쓰레드_개수)
    종료_인덱스 = 시작_인덱스 + (반복_횟수 // 쓰레드_개수)

    시작_인덱스부터 종료_인덱스까지 반복:
        랜덤한_숫자 = 난수_생성()
        합계 = 합계 + 랜덤한_숫자
```

## 동시성 이슈

위 슈도 코드에서는 Race Condition이 발생할 수 있다. 여러 개의 Thread가 동시에 합계에 접근하여 스레드 간의 실행 순서나 시간 차에따라 결과가 달라질 수 있다.

합계에 뮤텍스를 걸어버리면 문제를 해결할 수 있지만, 성능이 크게 저하될 수 있다.

그래서 아래의 방법을 사용할 수 있다.

```
합계 = 0
반복 횟수 = 1_000_000_000
쓰레드_개수 = 시스템_쓰레드_개수()

# 쓰레드 간 합을 계산하기 위한 임시 변수들을 초기화
임시_합계들 = [쓰레드_개수]

# 숫자를 쓰레드로 분할하여 합을 계산
각 쓰레드에 할당:
    시작_인덱스 = 현재_쓰레드 * (반복_횟수 / 쓰레드_개수)
    종료_인덱스 = 시작_인덱스 + (반복_횟수 / 쓰레드_개수)
    임시_합계 = 0

    시작_인덱스부터 종료_인덱스까지 반복:
        랜덤한_숫자 = 난수_생성()
        임시_합계 = 임시_합계 + 랜덤한_숫자

    임시_합계들[현재_쓰레드] = 임시_합계

# 모든 쓰레드의 임시 합계를 전체 합계에 더합니다.
스레드 개수만큼 반복:
    합계 = 합계 + 임시_합계들[현재_쓰레드]
```

해당 부분은 각 스레드가 합계를 따로 저장하고, 전체 합계를 구할 때는 선형적으로 계산한다.

결과적으로 전체 로직의 대부분을 차지하는 스레드 별 합계를 구하는 로직은 병렬로 처리할 수 있게 된다.