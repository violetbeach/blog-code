## 모듈

모듈 설계는 아래와 같았다.
- API
- GateWay
- Batch
- Admin
- Common

문제점은 아래와 같다.
- 작업 수행 및 히스토리 파악이 어렵다.
  - Common, API, GateWay 모두 수정하게 되면서 코드 반영이 어렵고 이후 추적도 어렵다.
- 서비스 분리가 어렵다.
- SRP를 위반하기 쉽다.
  - `변경할 이유(액터의 수)가 하나여야 한다.`는 원칙을 위배할 수 있음
- Common 변경의 어려움
  - 개발 독립성, 배포 독립성의 확보 X
  - 신속한 장애해결이 어려움

## 시스템에 독립적인 공통 코드 분리하기

- 시스템에 **독립적인 공통 코드**: StringUtils, ...
- 시스템에 종속적인 공통 코드:
  - 도메인 공통 코드: App, AppStatus, ProductCode
  - 인프라 공통 코드: DatabaseConfig, CacheConfig

여기서 도메인을 가지지 않는 시스템에 독립적인 공통 코드는 `global-utils`라는 이름을 지었다.

도메인을 가지는 도메인 공통 코드와 인프라 공통 코드는 `서로 다른 수준`이고 `서로 다른 변경 속도`를 가진다. 그래서 `{}-core:infra` 모듈과 `{}-core:domain` 모듈로 분리했다.

## 실행 모듈

여기서 실행 모듈의 특성에 따라 또 나눌 수 있는 부분이 생긴다.

- api: RestDocs, ...
- 관리자용 기능: Thymeleaf, ...
- 배치 작업: Spring Batch, ...

## 유스케이스

사이드 이펙트는 SRP를 위반하기 때문에 생긴다. 유스케이스를 공통화하면 SRP를 위반하게 된다.

그래서 유스케이스를 공통화하지 않고 각 사용자(API, Batch, ...)에서 중복으로 구현한다.

> 이 부분의 경우 이전 Naver Music 강연에서도 봤지만, 확신이 없다.
> 확실히 사이드 이펙트는 제거할 수 있지만 UseCase의 변경된 내용을 각 모듈에서 반영해야 하는 점 역시 최선책은 아닐 것이다.

## 공통 모듈 제어

공통 모듈을 제어하기 위한 방법들을 살펴보자.
- 컴파일 제한: 언어 차원(Package-private 가시성 등) 또 빌드 도구를 활용한 컴파일 제한
- 빌드 제한: 빌드 도구 혹은 ArchUnit 라이브러리 등을 활용해서 제한
  - `api, compile`보다는 `implementation`을 사용해서 전이 의존성 제거
  - 좋은 시스템은 제약이 많은 시스템
  - 불필요한 컴파일에 의해 빌드 시간이 늘어나는 것 방지
- 머지 제한: Merge를 위한 최소 Approve 수 제한 등
- 기타: Github Actions를 이용한 변경 모듈 라벨링 등
