## Consumer

## 컨슈머 그룹

토픽 파티션은 컨슈머 그룹 단위로 할당된다.
- 1개 그룹의 컨슈머 수가 파티션 개수보다 많으면 컨슈머가 아무 작업도 하지 못하게 된다.
- 즉, 파티션의 개수는 컨슈머 그룹의 컨슈머 수보다 작아야 한다.

## 커밋과 오프셋

메시지를 소비할 때는 Offset을 신경써야 한다.
- 컨슈머 그룹은 이전 커밋 Offset이 있으면 그 이후에 poll한 메시지의 마지막 Offset을 커밋한다.

만약 처음 접근하거나 커밋한 오프셋이 없는 경우 아래의 설정을 따른다.
- auto.offset.reset 설정으로 제어할 수 있다.
  - earliest - 맨 처음 오프셋 사용
  - latest - 가장 마지막 오프셋 사용 (default)
  - none - 컨슈머 그룹에 대한 이전 커밋이 없으면 익셉션 발생 (일반적으로 사용하지 않음)

#### 자동 커밋

아래는 커밋에 관련된 설정이다.

- enabled.auto.commit - 커밋은 크개 두 가지 방법이 있다.
  - true (자동 커밋) - 일정 주기로 컨슈머가 읽은 오프셋을 커밋한다. (default)
  - false (수동 커밋) - 수동으로 커밋을 실행한다.
- auto.commit.interval.ms (default: 5s)
  - 자동 커밋 시 주기
- poll(), close() 메서드 호출 시 자동 커밋 실행

## 처리량

컨슈머의 처리량에 영향을 주는 옵션은 크게 3가지가 있다.
- fetch.min.bytes (default: 1)
  - 조회 시 브로커가 전송할 최소 데이터 크기
  - 이 값이 크면 대기 시간이 늘지만 처리량이 증
- fetch.max.wait.ms (default: 500)
  - 데이터가 최소 크기가 될 때까지 기다릴 시간
  - **브로커가 리턴할 때까지 기다리는 시간으로 poll() 메서드의 대기시간과 다르다.**
- max.partition.fetch.bytes (default: 1MB)
  - 파티션 당 서버가 리턴할 수 있는 최대 크기를 지정

## 멱등성

컨슈머가 동일한 메시지를 읽을 수도 있다는 사실을 주의해야 한다.
- 일시적 커밋 실패
- 리밸런스

따라서 컨슈머는 멱등성(idempotence)를 고려해서 설계해야 한다.
- 예를 들어, 조회수 1 증가 -> 좋아요 1 증가 -> 조회수 1증가를 처리할 때
- 멱등성을 고려하지 않으면 조회수가 4개 될 수 있다.
- 데이터 특성에 따라 TimeStamp나 일련 번호 등을 활용할 수 있다.

## 연결

컨슈머는 하트비트를 전송해서 연결을 유지한다.
- 브로커는 일정시간 컨슈머로부터 하트비트가 없으면 컨슈머를 그룹에서 빼고 리밸런스를 수행한다.
  - session.timeout.ms: 세션 타임 아웃 시간 (default: 10s)
  - heartbeat.interval.ms: 하트비트 전송 주기 (default: 3s)
    - 일반적으로 session.timeout.ms의 1/3 이하가 권장된다.
  - max.poll.interval.ms (default: 5m)
    - 파티션 무한 점유를 막기 위한 설정
    - 해당 시간이 지나도록 poll()를 수행하지 않으면 컨슈머를 그룹에서 빼고 리밸런스를 수행
    - 로직이 오래걸리는 경우 해당 설정을 로직 수행시간보다는 늘려야 불필요한 리밸런스를 막을 수 있다. 




