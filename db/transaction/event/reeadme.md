## 선착순 이벤트를 처리하기 위한 방법들 (Queue, Lock, Isolation, ...)


더 자세히 알고 싶으면 아래 강연을 보는 것을 권해드린다!
- https://www.youtube.com/watch?v=MTSn93rNPPE

## 참고
- https://velog.io/@hgs-study/redis-sorted-set 처리하기 위한 방법들 (Queue, Lock, Isolation, ...)

만약에 특정 기업에서 선착순 50명에게 맥북을 1만원에 파는 이벤트를 한다고 하자.

어떻게 처리하면 될까..?

## 문제 상황

'그냥 DB에 Select하고 50명이 없을 경우 Insert하면 되지 않나??' 라고 생각하면 안되다.

다수의 스레드가 SELECT를 수행한 시점에 50건이 없었다면, 모두 Insert를 수행할 것이다.

이러한 실시간 선착순 이벤트에서 고려해야 하는 부분은 다음과 같다.
- 다수의 서버, 다수의 스레드에서 동시성을 어떻게 보장할 지
- 한 번에 쏠리는 트래픽을 어떻게 처리할 지

## 1. Redis

대표적인 솔루션으로 Redis를 적용할 수 있다.

Redis의 경우 분산 처리가 가능하고 자원 낭비가 적고 효율적이라서 대용량 트래픽을 효과적으로 처리할 수 있고,

추가로 싱글 스레드로 동작하기 때문에 데이터가 atomic하게 유지되어 동시성 이슈를 해결할 수 있다.

요청을 저장할 수 있는 자료구조로는 아래 두 가지가 있습니다.
- List
- Set
- Sorted Set

### List

List의 경우에는 삽입에서 O(1)이 소요되지만, 자신의 존재 여부나 순서를 파악하기 위해서 순차 탐색을 하게 되므로 O(n)이 소요된다

즉, 중복으로 쿠폰이 발행되지 않는다는 요구사항이 있으면 List를 사용하는 것을 부적절하다.

### Set, Sorted Set

Set과 Sorted Set은 자신의 존재 여부를 파악하는 데 O(1)이 소요되기에 List의 중복 체크에서 시간 복잡도가 소요되는 문제를 해결할 수 있다.

Set의 경우는 삽입에서 O(log(1))이 소요되고, Sorted Set의 경우 삽입에서O(log(N))이 소요되지만 요청 순서대로 정렬하는 것이 가능하다.

만약 나중에 정렬해둔 데이터를 가지고 N 명을 뽑는다면 Sorted Set이 적합하지만, 실시간으로 바로 쿠폰을 발급해주는 등의 처리를 하는 데에는 Set을 사용할 수 있다.

### Transaction

위에서 Redis (Set 자료구조)를 선택했더라면 아래와 같이 구현할 수 있을 것이다.
- Redis에서 이벤트의 재고를 조회
- Set을 생성 후 재고가 존재한다면 지급 재고를 증가(INCR) 후 쿠폰을 발급

문제는 재고 조회와 쿠폰 발급이 동일 트랜잭션에서 이뤄져야 한다.

재고가 1개 남았는데, A 유저와 B 유저가 모두 이벤트의 재고 조회가 성공하면 쿠폰이 정해진 수량 이상 발급되는 문제가 발생한다.
- 이때는 Set에 쿠폰을 발급하는 것 까지 **트랜잭션**으로 묶어서 한 유저만 진입을 하도록 처리해야 한다.

#### LOCK

추가로 트랜잭션을 사용하더라도 다른 트랜잭션에서 커밋을 할 때까지 읽지 않고 대기해야 한다.

가령, 자바 서버가 100대 있다고 가정하자. 100대에서 전부 Redis를 통해 조회를 했을 때 재고가 0건나와서 전부 재고를 증가해버리면 트랜잭션도 의미가 없어진다.



#### 유실

추가로 Redis는 휘발성 DB라서 데이터 유실을 고려하여 재고 데이터는 반드시 메인 DB에 싱크를 해야 한다.

#### 결과

결과로 Redis를 활용해서 동시성 이슈를 해결했고, 선착순 등록에 실패한 경우 실제 DB에 영향을 주지 않을 수 있고, 분산처리 까지 가능하게 되었다.

그렇지만 해당 Redis를 사용한 것은 사실 선착순 이벤트에서의 폭발적인 트래픽을 감당하기 위함이 크다.

일반적인 선착순 자원 예약이라던지 쇼핑몰 등에서의 판매 처리는 Redis라는 추가 인프라를 활용하기가 설계가 복잡해진다는 문제가 있다.

그렇다면 Redis를 사용하지 않으면 폭발적인 트래픽이라는 요구 사항을 제외하면 어떻게 구현할 수 있을까..?

## 2. 락 (+ 트랜잭션 고립 수준)

동시성 제어를 위한 가장 보편적인 방법은 락이다.

락을 통해 트랜잭션들을 줄세우고 처리하면 동시성 이슈를 해결할 수 있다.

해당 방법은 불필요한 대기 상태를 만드는 것을 최소화하는 것이 관건이다.
- (MySQL에서는 특히나 인덱스를 잠그기 때문에 WHERE 조건에 따라 락의 영향 범위가 커질 수 있다.)
  - 해당 작업으로 인해 다른 쿼리가 대기하게 되진 않을 지 고려해야 한다. 

### 2-1. 비관적 락

락을 이용하면 해당 이슈를 해결이 가능하다.

가령, 재고를 조회하는 트랜잭션에 비관적 락을 건 후, 쿠폰을 발급하는 트랜잭션의 고립 수준을 READ COMMITTED 이상으로 적용하면 동시성 이슈를 깔끔하게 해결이 가능하다.
- (다른 트랜잭션에서 자원의 재고에 접근하지 못하도록 락을 걸어서 대기시키기 때문)

여기서 RDB만으로 사용하고 있다면 중복 발급 체크 로직이이 실패할 수 있지는 않는 지 검토해야 한다.

만약 유저id에 UNIQUE 인덱스가 없다면 중복 체크(한 유저가 쿠폰이 이미 존재하는 지 체크) 시 Phantom Read로 인해 동시성 이슈가 발생할 수 있습니다.
- InnODB를 사용하고 있다면 유저 기반의 인덱스가 걸려있을 때 Record 락이 걸리므로 해당 이슈가 발생하지 않을 것이다.

비관적 락의 경우에는 레코드 자체에 락을 걸기 때문에 대기 중인 쿼리가 쌓여서 성능상 이슈가 있다는 단점이 있다.

### 2-2. 낙관적 락

낙관적 락을 사용하면 레코드에 대해 버저닝을 해서 자원의 재고를 비관적 락처럼 요청들을 줄 세우지 않고 한꺼번에 처리할 수 있다. 
- 충돌을 실패로 처리하면서 선착순으로 폭발적인 트래픽이 들어오는 경우 많은 요청들이 대부분 실패하게 된다는 점을 주의해야 한다.

비관적 락의 경우 DB의 자원을 사용하는 데 반해, 낙관적 락의 경우 어플리케이션의 자원을 사용하므로 DB의 부담을 덜어줄 수 있다. 

추가적으로 낙관적 락에서도 비관적 락처럼 유저id에 대한 중복 체크 시 Phantom Read가 발생할 수 있다.

실패 처리도 직접 구현해야 하고, 롤백 기반으로 동작하기 때문에 동시 요청을 보낸 사용자가 많은 경우에 로직이 복잡할 수록 롤백 작업도 많아지므로 자원 소모가 크게 된다. 추가로 DB에 컬럼 하나가 추가로 필요하게 된다.


## 참고
- https://d2.naver.com/helloworld/5048491
- https://brunch.co.kr/@springboot/205
- https://velog.io/@ohzzi/Redis%EB%A5%BC-%ED%99%9C%EC%9A%A9%ED%95%98%EC%97%AC-%EB%8F%99%EC%8B%9C%EC%84%B1-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0%ED%95%98%EA%B8%B0